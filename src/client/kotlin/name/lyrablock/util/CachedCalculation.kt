package name.lyrablock.util

import java.lang.ref.SoftReference
import java.util.*
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.locks.ReentrantLock
import kotlin.collections.LinkedHashMap

/**
 * Cached calculation utility class (Generated by AI)
 *
 * Uses LRU (Least Recently Used) for cache management and supports soft references for memory efficiency.
 *
 * @param maxSize The max size of the cache
 * @param useSoftReferences Whether to use soft references for cached values
 */
class CachedCalculation<K, D, V>(
    private val maxSize: Int = 100,
    private val useSoftReferences: Boolean = true
) {
    // Thread-safe cache storage
    private val cache = ConcurrentHashMap<K, CacheEntry<D, V>>()

    private val accessOrder = object : LinkedHashMap<K, Unit>(maxSize, 0.75f, true) {
        override fun removeEldestEntry(eldest: MutableMap.MutableEntry<K, Unit>?): Boolean {
            return size > maxSize
        }
    }
    private val accessOrderLock = ReentrantLock()

    // A key for every value
    private val keyLocks = ConcurrentHashMap<K, ReentrantLock>()
    private val lockStripes = (0 until 16).map { ReentrantLock() }.toTypedArray()

    /**
     * Calculate and cache the result
     *
     * @param key The key for the cached value
     * @param dependency Dependency that causes re-calculation if changed
     * @param function The function to compute
     * @return The result
     */
    fun calculateCached(key: K, dependency: D, function: () -> V): V {
        // The current value of key
        val stripeLock = lockStripes[key.hashCode().absoluteValue() % lockStripes.size]
        stripeLock.lock()
        try {
            // Validate the cache
            val cached = cache[key]
            if (cached != null && cached.isValid(dependency)) {
                updateAccessOrder(key) // 更新访问顺序
                return cached.getValue() // 返回缓存值
            }

            // The lock of the key
            val keyLock = keyLocks.computeIfAbsent(key) { ReentrantLock() }
            keyLock.lock()
            try {
                // Double-check the key
                val recheck = cache[key]
                if (recheck != null && recheck.isValid(dependency)) {
                    updateAccessOrder(key)
                    return recheck.getValue()
                }

                // The actual calculation
                val result = function()
                val entry = createCacheEntry(dependency, result)

                // Update the cache
                cache[key] = entry
                updateAccessOrder(key)

                return result
            } finally {
                keyLock.unlock()
                // Remove key lock if no longer needed
                if (keyLock.queueLength == 0) {
                    keyLocks.remove(key)
                }
            }
        } finally {
            stripeLock.unlock()
        }
    }

    /**
     * Clear ALL cached values
     */
    fun clearCache() {
        accessOrderLock.lock()
        try {
            cache.clear()
            accessOrder.clear()
        } finally {
            accessOrderLock.unlock()
        }
    }

    /**
     * Remove a specific cached value by key
     */
    fun invalidate(key: K) {
        accessOrderLock.lock()
        try {
            cache.remove(key)
            accessOrder.remove(key)
        } finally {
            accessOrderLock.unlock()
        }
    }

    /**
     * The current cache size
     */
    fun cacheSize(): Int = cache.size

    /**
     * Get all cached keys
     */
    fun cachedKeys(): Set<K> = Collections.unmodifiableSet(cache.keys)

    // Update access order (for LRU)
    private fun updateAccessOrder(key: K) {
        accessOrderLock.lock()
        try {
            accessOrder[key] = Unit

            // 如果超过最大大小，移除最旧条目
            if (accessOrder.size > maxSize) {
                val eldest = accessOrder.entries.firstOrNull()
                eldest?.key?.let { cache.remove(it) }
            }
        } finally {
            accessOrderLock.unlock()
        }
    }

    // Create a cache entry based on the type of reference
    private fun createCacheEntry(dependency: D, value: V): CacheEntry<D, V> {
        return if (useSoftReferences) {
            SoftRefCacheEntry(dependency, value)
        } else {
            SimpleCacheEntry(dependency, value)
        }
    }

    private interface CacheEntry<D, V> {
        fun isValid(currentDependency: D): Boolean
        fun getValue(): V
    }

    private class SimpleCacheEntry<D, V>(
        private val dependency: D,
        private val value: V
    ) : CacheEntry<D, V> {
        override fun isValid(currentDependency: D): Boolean = dependency == currentDependency
        override fun getValue(): V = value
    }

    private class SoftRefCacheEntry<D, V>(
        private val dependency: D,
        value: V
    ) : CacheEntry<D, V> {
        private val valueRef: SoftReference<V> = SoftReference(value)

        override fun isValid(currentDependency: D): Boolean {
            return dependency == currentDependency && valueRef.get() != null
        }

        override fun getValue(): V {
            return valueRef.get() ?: throw IllegalStateException("Value has been garbage collected")
        }
    }
}

// Kotlin扩展函数使绝对值计算更简洁
private fun Int.absoluteValue() = if (this < 0) -this else this
